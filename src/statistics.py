import time
from pathlib import Path
from loguru import logger
from src.openapiParser import Parser
from src.sca import SCA
from typing import List, Tuple, Set
from src.ca import CA, Executor
from src.Dto.parameter import Example
from itertools import combinations
from src.Dto.operation import Operation
import sys

class Timer:
    def __init__(self, data):
        self._data = data

    def __call__(self, func):
        def _timer_wrapper(*args, **kwargs):
            start = time.time()
            func(*args, **kwargs)
            end = time.time()
            self._data.register_case_time(end - start)
        return _timer_wrapper


# class Data:
#     def __init__(self, folder):
#         self._folder = folder
#
#         self.seq_to_covered = 0
#         self.seq_still_uncovered = 0
#
#         # the start and stop of the testing
#         self.start_time = None
#         self.stop_time = None
#
#         # consumed milliseconds by each test case
#         self._secs_per_request = []
#
#         # the length of each test sequence generated by SCA
#         self._seq_num: List[int] = []
#         # the total number of covered operation tuples
#         self._total_seq_combinations: Set[Tuple] = set()
#         # the covered operation tuples that have success request sequences
#         self._success_seq_combinations: Set[Tuple] = set()
#
#         # the number of covering array of CA
#
#
#     @property
#     def _avg_seq_length(self):
#         return sum(self._seq_num) / len(self._seq_num)
#
#     @property
#     def _avg_consumed_time(self):
#         return sum(self._secs_per_request) / len(self._secs_per_request)
#
#     @property
#     def _request_num(self):
#         return len(self._secs_per_request)
#
#     @property
#     def register_case_time(self, milliseconds):
#         self._secs_per_request.append(milliseconds)
#
#     def start_test(self):
#         self.start_time = time.time()
#
#     def stop_test(self):
#         self.stop_time = time.time()
#
#     def getSequenceTested(self):
#         """
#         Compute the proportion of 1-way and 2-way sequences that are actually tested
#         @:return: 1-way tested, 1-way all,  2-way tested, 2-way all, still uncovered SStrength-way due to timeout, all uncovered SStrength-way
#         """
#         return self._computeCombinations(CA.successSet, 1), \
#                self._computeCombinations(SCA.members, 1), \
#                self._computeCombinations(CA.successSet, 2), \
#                self._computeCombinations(SCA.members, 2), \
#                self.uncovered
#
#     def getBugInfo(self):
#         return len(CA.bugList)
#
#     def getRestCallNumber(self):
#         return Executor.callNumber
#
#     def getCost(self):
#         """
#         :return: in minutes
#         """
#         return Report.Cost / 60
#
#     def _computeCombinations(self, seqSet, strength):
#         coveredSet = set()
#         for seq in seqSet:
#             if len(seq) < strength:
#                 continue
#             for c in combinations(seq, strength):
#                 coveredSet.add(tuple(c))
#         return len(coveredSet)
#
#     def report(self, outputFolder):
#         seq, length = Report.getSequenceInfo()
#         c_1, c_1_a, c_2, c_2_a, a_c = Report.getSequenceTested()
#         bug = Report.getBugInfo()
#         total = Report.getRestCallNumber()
#         cost = Report.getCost()
#
#         file = Path(outputFolder) / "statistics.csv"
#         columns = ["columnId", "SStrength", "EStrength", "AStrength", "Seq", "Len", "C_1_way", "C_2_way", "All C_SStrength_way", "Bug",
#                    "Total", "Cost"]
#         if not file.exists():
#             with file.open("w") as fp:
#                 fp.write(",".join(columns))
#                 fp.write("\n")
#
#         data = "{},{},{},{},{},{:.2f},{:.2f},{:.2f},{},{},{},{:.2f}\n".format(.columnId, RESTCT.SStrength, RESTCT.EStrength, RESTCT.AStrength, seq, length, c_1 / c_1_a, c_2 / c_2_a, a_c, bug, total, cost)
#         with file.open("a") as fp:
#             fp.write(data)
#             logger.info("{},{},{},{},{},{:.2f},{:.2f},{:.2f},{},{},{},{:.2f}\n".format(RESTCT.columnId, RESTCT.SStrength, RESTCT.EStrength, RESTCT.AStrength, seq, length, c_1 / c_1_a, c_2 / c_2_a, a_c, bug, total, cost))



